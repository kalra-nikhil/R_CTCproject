---
title: "CTC Analysis"
author: "Nikhil Kalra"
format: 
  docx:
    #reference-doc: "PhD-thesis_NK_2024-11"
    toc: true
  pdf:
    toc: true
editor: visual
execute:
  echo: true
  warning: false
  output: asis
fig-dpi: 300
fig-width: 6
fig-height: 8
tbl-cap-location: top
---

# Loading packages

```{r}
pacman::p_load(broom, 
               broom.mixed,
               car,
               conflicted, 
               DHARMa, performance,
               fitdistrplus,        # For fitdist(), plotdist(): estimate distribution parameters and plot them
               flextable, 
               formattable, 
               ggbeeswarm,
               ggalluvial, 
               ggbreak, 
               GLMMadaptive, glmmTMB,
               here,
               irr,                # For Cohen's kappa     
               knitr,
               lme4,
               multcomp,
               ordinal,
               purrr,
               patchwork,
               pscl,               # For zeroinfl()
               readxl, 
               scales,
               stats,              # For Wilcoxon test
               tau,                # For Kendall's tau
               tidyverse,
               vcd,                # For McNemar test
               wrappedtools)

conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)
conflicts_prefer(dplyr::recode)
conflicts_prefer(formattable::comma)
conflicts_prefer(readxl::read_xlsx)
conflicts_prefer(dplyr::slice)

# Ensure flextables are printed in Quarto Word
knit_print.flextable <- function(x, ...) {
  knitr::knit_print(as_flextable(x))
}
```

# Importing data

```{r}
biopsydata <- read_xlsx(here("Data/CTCdata.xlsx"))
# baselinedata <- read_xlsx(here("Data/CTCanalysis_NK.xlsx"), 
#                                sheet = 2)
qualvars <- ColSeeker(biopsydata,
                     namepattern=c("^C","meno","Stanze","Ne"))
```

# Data Cleaning

## Mutating Pathology column

```{r}
rawdata <- 
  biopsydata |> 
  mutate(
    patho_ER = case_when(
      str_detect(Pathology, ".*?ER\\s*[><=]?\\s*\\d+%?.*") ~
        str_replace(Pathology, ".*?(ER\\s*[><=]?\\s*\\d+%?).*", "\\1") |> 
        str_replace("ER\\s*[><=]?\\s*", "")
    ),
    patho_PR = case_when(
      str_detect(Pathology, ".*?PR\\s*[><=]?\\s*\\d+%?.*") ~
        str_replace(Pathology, ".*?(PR\\s*[><=]?\\s*\\d+%?).*", "\\1") |> 
        str_replace("PR\\s*[><=]?\\s*", "")
    ),
    patho_HER2 = case_when(
      str_detect(Pathology, ".*HER2 \\D{3}.*") ~
        str_replace(Pathology, ".*(HER2 \\D{3}).*", "\\1") |> 
        str_replace("HER2 ", "")
    ),
    patho_Ki67 = case_when(
      str_detect(Pathology, "Ki67 <?\\d+%") ~
        str_replace(Pathology, ".*(Ki67 <?\\d+%).*", "\\1") |> 
        str_replace_all("Ki67\\s*|[<%]", "")
    )
  ) |> 
  mutate(
    across(all_of(qualvars$names), factor) # Convert specific columns to factors
  )

```

## Mutating Staging column

```{r}
identifiers <- c("T", "N", "M", "G", "L", "V", "n", "R")

# Extract columns dynamically and automate column naming
rawdata <- rawdata |>
  mutate(Staging = replace_na(Staging, "")) |>  # Replace NA with empty strings
  bind_cols(
    map_dfc(identifiers, ~ tibble(!!paste0(.x, "_stage") := str_extract(rawdata$Staging, paste0(.x, "[A-Za-z0-9]{1}"))))
  ) |>
  mutate(across(ends_with("_stage"), ~ str_replace_all(., "^.*?(\\w)$", "\\1")))  # Extract only single character

```

# Selecting cases for analysis

1.  Cases where Epithelial cells were detected have to excluded from the study
2.  Cases with incomplete/damaged/discarded blood have to excluded as well

```{r}
rawdata <- 
  rawdata |> 
  mutate(
    complete=case_when(
      # Stanze_type != "Not_received" &
      #   Cell_Category != "Epithelial"~ "yes",
      Stanze_type == "Not_received" | 
        Cell_Category == "Epithelial" ~ "no",
      .default = "yes"),
    CApositive=case_when(
      complete == "yes" &
        Cancer == "positive" ~ "yes",
      complete == "yes" &
        Cancer == "negative" ~ "no"))

#Summary_table for samples included in analysis
summary_data <- rawdata |>
  group_by(Cancer) |>
  summarise(
    overall_cases = n(),  # Total cases
    selected_cases = sum(complete == "yes", na.rm = TRUE)) |>  # Selected cases
  mutate(
    overall_freq = formattable::percent(overall_cases / sum(overall_cases)),
    selected_freq = formattable::percent(selected_cases / sum(selected_cases)))

bind_rows(
  summary_data,
  tibble(
    Cancer = "Total",
    overall_cases = sum(summary_data$overall_cases, na.rm = TRUE),
    selected_cases = sum(summary_data$selected_cases, na.rm = TRUE),
    overall_freq = formattable::percent(1),  # Total frequency = 100%
    selected_freq = formattable::percent(1)  # Total selected frequency = 100%
  )
) |> flextable()

```

# Table 1 : Clinicopathological parameters

```{r}
#| eval: false
#| fig.height: 4
# Age plot
rawdata |>
  filter(complete=="yes") |>
  select(Age, Cancer) |> 
  filter(!is.na(Age)) |> 
  ggplot(aes(Age, color=Cancer)) + geom_density()

# p-value: Age
## Normality test
rawdata |> 
  filter(complete == "yes") |>
  group_by(Cancer) |> 
  summarise(cases = n(),
            shapiro_pvalue = shapiro.test(Age)$p.value) |> 
  flextable()

## Wilcoxon test
rawdata |> 
  filter(complete == "yes") |>
  wilcox.test(Age ~ Cancer, data = _)

# CTC positive cases before biopsy
rawdata |> 
  filter(complete == "yes") |> 
  group_by(Cancer) |> 
  summarise(
    Method01 = list(Method01_pre[Method01_pre > 0]),
    Method02 = list(Method02_pre[Method02_pre > 0])
  ) |> 
 summarise(
    shapiro_CTCs_Method01 = shapiro.test(unlist(Method01))$p.value,
    shapiro_CTCs_Method02 = shapiro.test(unlist(Method02))$p.value,
    wilcox_pvalue = wilcox.test(unlist(Method01), unlist(Method02), exact = FALSE)$p.value
  )|> 
  flextable()

# CTC counts before biopsy
rawdata |> 
  filter(complete == "yes") |> 
  select(Patient_ID, Cancer, Method01_pre, Method02_pre) |> 
  group_by(Cancer) |> 
  summarise(
    across(
      contains("Method"),
      ~ sum(.x, na.rm = TRUE),
      .names = "{.col}_sum"
    ))|> 
  flextable()

# Clinical variables
# Initialize a list to store results
table <- list()

# Total counts
table$total <- nrow(rawdata |> filter(complete=="yes"))

# Breast cancer status counts
table$cancer <- rawdata |> 
  filter(complete=="yes") |> 
  group_by(Cancer)  |> 
  summarise(cases = n()) |> 
  mutate(freq = formattable::percent(cases / sum(cases)))

# Age at diagnosis: median, min, max
table$age <- rawdata |> 
  filter(complete=="yes") |> 
  group_by(Cancer) |>
  summarise(
    median = median(Age, na.rm = TRUE),
    min = min(Age, na.rm = TRUE),
    max = max(Age, na.rm = TRUE))

# Menopause status
table$menopause <- rawdata |> 
  filter(complete == "yes") |> 
  mutate(
    Menopause = ifelse(Menopause == "perimenopausal", "postmenopausal", Menopause)
  ) |> 
  # Calculate global totals for CA groups
  mutate(
    total_CAnegative = sum(Cancer == "negative", na.rm = TRUE),
    total_CApositive = sum(Cancer == "positive", na.rm = TRUE)
  ) |> 
  group_by(Menopause) |> 
  summarise(
    negative = sum(Cancer == "negative", na.rm = TRUE),
    positive = sum(Cancer == "positive", na.rm = TRUE),
    total_CAnegative = first(total_CAnegative),  # Use global totals for CA-negative
    total_CApositive = first(total_CApositive),  # Use global totals for CA-positive
    CA_negative = paste0(negative, " (", formattable::percent(negative / total_CAnegative), ")"),
    CA_positive = paste0(positive, " (", formattable::percent(positive / total_CApositive), ")")
  ) |> 
  select(Menopause, CA_positive, CA_negative)

# Tissue biopsy
table$biopsy <- rawdata |> 
  filter(complete=="yes") |> 
  mutate(
    total_negative = sum(Cancer == "negative", na.rm = TRUE),
    total_positive = sum(Cancer == "positive", na.rm = TRUE)
  ) |> 
  group_by(Stanze_type) |> 
  summarise(
    negative = sum(Cancer == "negative", na.rm = TRUE),
    positive = sum(Cancer == "positive", na.rm = TRUE),
    total_CAnegative = first(total_negative),
    total_CApositive = first(total_positive),
    CA_negative = paste0(negative," (", formattable::percent(negative/total_CAnegative),")"),
    CA_positive = paste0(positive," (", formattable::percent(positive/total_CApositive),")")) |> 
  select(Stanze_type, CA_positive, CA_negative)

# Tissue histology
rawdata |> 
  filter(complete == "yes", Cancer=="positive") |> 
  select(Cancer, Histology) |> 
  mutate(
    CApos_hist = case_when(
      grepl("IDC|NST", Histology, ignore.case = TRUE) ~ "IDC/NST",
      grepl("DCIS", Histology, ignore.case = TRUE) ~ "DCIS",
      is.na(Histology) ~ "NA",
      TRUE ~ Histology)) |> 
  group_by(CApos_hist) |> 
  summarise(
    Cases = n()) |> 
  ungroup() |> 
  mutate(Percentage = (Cases / sum(Cases)) * 100)|> 
  flextable()

rawdata |> 
  filter(complete=="yes", Cancer=="negative") |> 
  select(Cancer, Histology) |>  
  mutate(
    CAneg_hist = case_when(
      grepl("Fibrosis|Periductal Fibrosis|Fibrous Mastopathy|Cyst|Benign Cyst| Fibromatosis|Necrotic tissue", Histology, ignore.case = TRUE) ~ "Fibrous Lesions",
      grepl("Fibroadenoma|Fibroma|Hemartom", Histology, ignore.case = TRUE) ~ "Fibrous Tumors",
      grepl("Intraductal Papilloma|UDH|CLIS", Histology, ignore.case = TRUE) ~ "Epithelial lesions",
      is.na(Histology) ~ "NA",
      TRUE ~ Histology)) |> 
  group_by(CAneg_hist) |> 
  summarise(
    Cases = n()) |> 
  ungroup() |> 
  mutate(Percentage = (Cases / sum(Cases)) * 100)|> 
  flextable()

# Calculating Table 1 values for ER, PR, HER2, Ki67%
# ER_status
table$ER_status <- rawdata |> 
  filter(complete=="yes") |> 
  mutate(
    ER_status = case_when(
      patho_ER == "0" ~ "0",
      is.na(patho_ER) ~ "NA",
      as.numeric(patho_ER) > 0 ~ ">0"
      # .default = ">0"
      # TRUE ~ ">0"
      )) |> 
  group_by(ER_status) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(ER_status, CA_positive, CA_negative)

# PR_status
table$PR_status <- rawdata |> 
  filter(complete=="yes") |> 
  mutate(
    PR_status = case_when(
      patho_PR == "0" ~ "0",
      is.na(patho_PR) ~ "NA",
      as.numeric(patho_PR) > 0 ~ ">0"
      # .default = ">0"
      # TRUE ~ ">0"
      )) |> 
  group_by(PR_status) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(PR_status, CA_positive, CA_negative)

# HER2_status
table$HER2_status <- rawdata |> 
    filter(complete=="yes") |> 
    group_by(patho_HER2) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(patho_HER2, CA_positive, CA_negative)

# Ki67_status
table$Ki67_status <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
    patho_Ki67 = case_when(
      patho_Ki67 <= 15 ~ "<=15% (low)",
      patho_Ki67 > 15 ~ ">15% (high)",
      is.na(patho_Ki67) ~ "NA"
      # .default = ">0"
      # TRUE ~ ">0"
      )) |>
    group_by(patho_Ki67) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(patho_Ki67, CA_positive, CA_negative)

# Molecular subtype
rawdata |> 
  # Convert numeric columns while leaving patho_HER2 as character
  mutate(across(c(patho_ER, patho_PR, patho_Ki67), ~ as.numeric(.))) |> 
  filter(complete == "yes", Cancer=="negative") |> 
  select(Cancer, contains("patho_")) |>  
  # Apply the subtyping logic
  mutate(
    Subtype = case_when(
      # Luminal A
      (patho_ER > 0 | patho_PR > 0) & patho_HER2 == "neg" & patho_Ki67 <= 15 ~ "Luminal_A",
      # Luminal B
      (patho_ER > 0 | patho_PR > 0) & (patho_HER2 %in% c("neg", "pos")) & patho_Ki67 > 15 ~ "Luminal_B",
      # HER2-enriched
      patho_ER == 0 & patho_PR == 0 & patho_HER2 == "pos" & patho_Ki67 >= 0 ~ "HER2/neu",
      # Triple Negative Breast Cancer (TNBC)
      patho_ER == 0 & patho_PR == 0 & patho_HER2 == "neg" & patho_Ki67 >= 0 ~ "TNBC",
      # patho_ER == 0 & patho_PR == 0 & patho_HER2 == "neg" & (patho_Ki67 > 15 & patho_Ki67 <= 30) ~ "TNBC",
      # # Basal-like (Subtype of TNBC)
      # patho_ER == 0 & patho_PR == 0 & patho_HER2 == "neg" & patho_Ki67 > 30 ~ "Basal-like",
      # # Claudin-low (Subtype of TNBC, stem-like features)
      # patho_ER == 0 & patho_PR == 0 & patho_HER2 == "neg" & (patho_Ki67 >= 0 & patho_Ki67 <= 15) ~ "Claudin-low",
      # Triple Positive
      (patho_ER > 0 | patho_PR > 0) & patho_HER2 == "pos" & patho_Ki67 >= 0 ~ "Triple_Positive",
      # Normal-like
      # (patho_ER > 0 | patho_PR > 0) & patho_HER2 == "neg" & patho_Ki67 <= 15 ~ "Normal-like",
      # Default for unmatched cases
      TRUE ~ "NA")) |> # view()
  group_by(Subtype, Cancer) |> 
  summarise(Cases = n()) |> 
  ungroup() |> 
  mutate(Percentage = (Cases / sum(Cases)) * 100)|> 
  flextable()

# Staging: T, N, Metastasis
table$T_stage <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
    T_stage = case_when(
      T_stage == "i"  ~ "Tis",
      (T_stage == 1 | T_stage == 2) ~ "T1+T2",
      (T_stage == 3 | T_stage == 4) ~ "T3+T4",
      is.na(T_stage) ~ "NA"
      # .default = ">0"
      # TRUE ~ ">0"
      )) |>
    group_by(T_stage) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(T_stage, CA_positive, CA_negative)

# N stage
table$N_stage <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
    N_stage = case_when(
       N_stage == 0 ~ "N0", 
       N_stage == "x" ~ "Nx",
       N_stage == 1 ~ "N1",
      is.na(N_stage) ~ "NA")) |>
    group_by(N_stage) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(N_stage, CA_positive, CA_negative)

# M stage
table$M_stage <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
    M_stage = case_when(
      M_stage == 0 ~ "M0",
      M_stage == "x" | M_stage == "X" ~ "Mx",
      M_stage == 1 ~ "M1",
      is.na(M_stage) ~ "NA" )) |>
    group_by(M_stage) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(M_stage, CA_positive, CA_negative)

# Tumor grade
table$G_stage <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
    G_stage = case_when(
      (G_stage == 1 | G_stage == 2) ~ "G1+G2",
      (G_stage == 3) ~ "G3",
      is.na(G_stage) ~ "NA"
      )) |>
    group_by(G_stage) |> 
    summarise(negative = sum(Cancer == "negative", na.rm = TRUE),
              positive = sum(Cancer == "positive", na.rm = TRUE)) |>
    mutate(total_negative = sum(negative),
           total_positive = sum(positive),
           CA_negative = paste0(negative, " (", formattable::percent(negative / total_negative), ")"),
           CA_positive = paste0(positive, " (", formattable::percent(positive / total_positive), ")")) |>
    select(G_stage, CA_positive, CA_negative)

# Global function for all clinical parameters
variables <- c("L_stage", "V_stage", "n_stage", "R_stage")

# if (!exists("table")) table <- list()
# Loop through variables and assign results to table
for (var in variables) {
  table[[var]] <- rawdata |> 
    filter(complete=="yes") |> 
    mutate(
      Group = case_when(
        .data[[var]] == "0" ~ "0",
        is.na(.data[[var]]) ~ "NA",
        TRUE ~ "1"
      )
    ) |>
    group_by(Group) |>
    summarise(
      negative = sum(Cancer == "negative", na.rm = TRUE),
      positive = sum(Cancer == "positive", na.rm = TRUE)
    ) |>
    mutate(
      total_negative = sum(negative),
      total_positive = sum(positive),
      CA_negative = paste0(negative, " (",
                           formattable::percent(negative / total_negative), ")"),
      CA_positive = paste0(positive, " (",
                           formattable::percent(positive / total_positive), ")")
    ) |>
    select(Group, CA_positive, CA_negative)
}
head(table)
print(names(table))

```

# Table 2 & 3: CTC counts from both methods

```{r}
#| eval: false
# Overall cases:
rawdata |>  
  filter(complete == "yes") |> 
  filter(Cancer %in% c("positive", "negative")) |> 
  # Add combined columns
  mutate(
    Method01_combined = Method01_pre + Method01_post,
    Method02_combined = Method02_pre + Method02_post
  ) |> 
  # Select relevant columns
  select(matches("^(Method).*_(pre|post|combined)$"), -Method01_preII) |> 
  # Summarize metrics
  summarise(across(
    starts_with("Method"),
    list(
      sum = ~sum(.x, na.rm = TRUE),
      positive_cases = ~sum(.x > 0, na.rm = TRUE),
      median = ~median(.x[.x > 0], na.rm = TRUE),
      range = ~if (any(.x > 0, na.rm = TRUE)) {
        paste0(range(.x[.x > 0], na.rm = TRUE), collapse = " - ")
      } else {
        NA_character_
      }
    ),
    .names = "{.col}_{.fn}"  # Dynamically name columns
  )) |> 
  # Convert all columns to character
  mutate(across(everything(), as.character)) |> 
  # Reshape to long format
  pivot_longer(
    cols = everything(),
    names_to = c("Method", "Stage", "Metric"),
    names_pattern = "(Method\\d+)_(pre|post|combined)_(.*)"
  ) |> 
  # Reshape to wide format with pre, post, combined as columns
  pivot_wider(
    names_from = Stage,
    values_from = value
  ) |> 
flextable() |> set_table_properties(width = 0.9, layout = "autofit") |> 
  add_header_row(
    values = "CTCs identified pre-, post-biopsy and combined using two methods
    (overall cases, n=149)",
                 colwidths = 5) |>
  bold(part = "header")


# Malignant cases:
rawdata |>  
  filter(complete == "yes") |> 
  filter(Cancer %in% c("positive")) |> 
  # Add combined columns
  mutate(
    Method01_combined = Method01_pre + Method01_post,
    Method02_combined = Method02_pre + Method02_post
  ) |> 
  # Select relevant columns
  select(matches("^(Method).*_(pre|post|combined)$"), -Method01_preII) |> 
  # Summarize metrics
  summarise(across(
    starts_with("Method"),
    list(
      sum = ~sum(.x, na.rm = TRUE),
      positive_cases = ~sum(.x > 0, na.rm = TRUE),
      median = ~median(.x[.x > 0], na.rm = TRUE),
      range = ~if (any(.x > 0, na.rm = TRUE)) {
        paste0(range(.x[.x > 0], na.rm = TRUE), collapse = " - ")
      } else {
        NA_character_
      }
    ),
    .names = "{.col}_{.fn}"  # Dynamically name columns
  )) |> 
  # Convert all columns to character
  mutate(across(everything(), as.character)) |> 
  # Reshape to long format
  pivot_longer(
    cols = everything(),
    names_to = c("Method", "Stage", "Metric"),
    names_pattern = "(Method\\d+)_(pre|post|combined)_(.*)"
  ) |> 
  # Reshape to wide format with pre, post, combined as columns
  pivot_wider(
    names_from = Stage,
    values_from = value
  ) |> 
flextable() |> set_table_properties(width = 0.9, layout = "autofit") |> 
  add_header_row(
    values = "CTCs identified pre-, post-biopsy and combined using two methods
    (malignant cases, n=94)",
                 colwidths = 5) |>
  bold(part = "header")

```

## Overall CTC+ cases: Wilcoxon, McNemar, Kendall's tau, Cohen's kappa

```{r}
# Example data from the table
Method01_ctc <- list(
  pre = rawdata |> 
    filter(complete == "yes" ) |> 
    pull(Method01_pre),
  post = rawdata |> 
    filter(complete == "yes") |> 
    pull(Method01_post),
  combined = rawdata |> 
    filter(complete == "yes") |> 
    mutate(Method01_combined = Method01_pre + Method01_post) |> 
    pull(Method01_combined))

Method02_ctc <- list(
  pre = rawdata |> 
    filter(complete == "yes" ) |> 
    pull(Method02_pre),
  post = rawdata |> 
    filter(complete == "yes") |> 
    pull(Method02_post),
  combined = rawdata |> 
    filter(complete == "yes") |> 
    mutate(Method02_combined = Method02_pre + Method02_post) |> 
    pull(Method02_combined))

## Binary outcomes (positive or negative outcome) for each method
Metho01_binary <- list(
  pre = ifelse(Method01_ctc$pre > 0, 1, 0),
  post = ifelse(Method01_ctc$post > 0, 1, 0),
  combined = ifelse(Method01_ctc$combined > 0, 1, 0))

Method02_binary <- list(
  pre = ifelse(Method02_ctc$pre > 0, 1, 0),
  post = ifelse(Method02_ctc$post > 0, 1, 0),
  combined = ifelse(Method02_ctc$combined > 0, 1, 0))

# Ensure both datasets are paired (same number of observations)
if (length(Metho01_binary$pre) != length(Method02_binary$pre)) {
  stop("The data lengths for 'pre' measurements do not match!")
}

if (length(Metho01_binary$post) != length(Method02_binary$post)) {
  stop("The data lengths for 'post' measurements do not match!")
}

if (length(Metho01_binary$combined) != length(Method02_binary$combined)) {
  stop("The data lengths for 'post' measurements do not match!")
}

# Wicoxon Test
wilcoxon_pre <- wilcox.test(Method01_ctc$pre, Method02_ctc$pre, paired = TRUE, exact=FALSE)$p.value
wilcoxon_post <- wilcox.test(Method01_ctc$post, Method02_ctc$post, paired = TRUE, exact=FALSE)$p.value
wilcoxon_combined <- wilcox.test(Method01_ctc$combined, Method02_ctc$combined, paired = TRUE, exact=FALSE)$p.value

# McNemar Test
# prepare tables for McNemar's test
table_pre <- table(Metho01_binary$pre, Method02_binary$pre)
table_post <- table(Metho01_binary$post, Method02_binary$post)
table_combined <- table(Metho01_binary$combined, Method02_binary$combined)

# McNemar p-values
McNemar_pre <- mcnemar.test(table_pre)$p.value
McNemar_post <- mcnemar.test(table_post)$p.value
McNemar_combined <- mcnemar.test(table_combined)$p.value

# Kendall's Tau estimates: Correlation between CTC numbers
tau_pre <- cor.test(Method01_ctc$pre, Method02_ctc$pre, method="kendall")
tau_post <- cor.test(Method01_ctc$post, Method02_ctc$post, method="kendall")
tau_combined <- cor.test(Method01_ctc$combined, Method02_ctc$combined, method="kendall")

# Cohen's kappa for Pre- and Post-biopsy
kappa_pre <- kappa2(cbind(Metho01_binary$pre, Method02_binary$pre))
kappa_post <- kappa2(cbind(Metho01_binary$post, Method02_binary$post))
kappa_combined <- kappa2(cbind(Metho01_binary$combined, Method02_binary$combined))

# print results
data.frame(
  Statistic = c("Wilcoxon", "McNemar", "Kendall's Tau", "Cohen's Kappa"),
  Pre = c(
    round(wilcoxon_pre, 4),
    round(McNemar_pre, 4),
    paste0(round(tau_pre$estimate, 4), " (p=", round(tau_pre$p.value, 4), ")"),
    paste0(round(kappa_pre$value, 4), " (p=", round(kappa_pre$p.value, 4), ")")),
  Post = c(
    round(wilcoxon_post, 4),
    round(McNemar_post, 4),
    paste0(round(tau_post$estimate, 4), " (p=", round(tau_post$p.value, 4), ")"),
    paste0(round(kappa_post$value, 4), " (p=", round(kappa_post$p.value, 4), ")")),
  Combined = c(
    round(wilcoxon_combined, 4),
    round(McNemar_combined, 4),
    paste0(round(tau_combined$estimate, 4), " (p=", round(tau_combined$p.value, 4), ")"),
    paste0(round(kappa_combined$value, 4), " (p=", round(kappa_combined$p.value, 4), ")"))) |>
  flextable() |>
    set_caption(caption = "Overall cases: Pre-, Post- and Combined Analysis") |>
    autofit()


## Method02: Prepare contingency matrices for pre and post
# contingency_pre <- matrix(c(sum(Metho01_binary$pre == 1 & Method02_binary$pre == 1),
#                          sum(Metho01_binary$pre == 1 & Method02_binary$pre == 0),
#                          sum(Metho01_binary$pre == 0 & Method02_binary$pre == 1),
#                          sum(Metho01_binary$pre == 0 & Method02_binary$pre == 0)),
#                          nrow = 2)
# 
# contingency_post <- matrix(c(sum(Metho01_binary$post == 1 & Method02_binary$post == 1),
#                          sum(Metho01_binary$post == 1 & Method02_binary$post == 0),
#                          sum(Metho01_binary$post == 0 & Method02_binary$post == 1),
#                          sum(Metho01_binary$post == 0 & Method02_binary$post == 0)),
#                          nrow = 2)
# contingency_combined <- matrix(c(sum(Metho01_binary$combined == 1 &                         #                                      Method02_binary$combined == 1),
#                          sum(Metho01_binary$combined == 1 & Method02_binary$combined == 0),
#                          sum(Metho01_binary$combined == 0 & Method02_binary$combined == 1),
#                          sum(Metho01_binary$combined == 0 & Method02_binary$combined == 0)),
#                          nrow = 2)
```

## Malignant CTC+ cases: Wilcoxon, McNemar, Kendall's tau, Cohen's kappa

```{r}
Method01_ctc <- list(
  pre = rawdata |> filter(complete=="yes" & CApositive == "yes") |> pull(Method01_pre),
  post = rawdata |> filter(complete=="yes" & CApositive == "yes") |> pull(Method01_post),
  combined = rawdata |> 
             filter(complete=="yes" & CApositive == "yes") |>                                          mutate(Method01_combined = Method01_pre + Method01_post) |>                               pull(Method01_combined))

Method02_ctc <- list(
  pre = rawdata |> filter(complete=="yes" & CApositive == "yes") |> pull(Method02_pre),
  post = rawdata |> filter(complete=="yes" & CApositive == "yes") |> pull(Method02_post),
  combined = rawdata |> 
             filter(complete=="yes" & CApositive == "yes") |> 
             mutate(Method02_combined = Method02_pre + Method02_post) |>                               pull(Method02_combined))

## Binary outcomes (positive or negative outcome) for each method
Metho01_binary <- list(
  pre = ifelse(Method01_ctc$pre > 0, 1, 0),
  post = ifelse(Method01_ctc$post > 0, 1, 0),
  combined = ifelse(Method01_ctc$combined > 0, 1, 0))

Method02_binary <- list(
  pre = ifelse(Method02_ctc$pre > 0, 1, 0),
  post = ifelse(Method02_ctc$post > 0, 1, 0),
  combined = ifelse(Method02_ctc$combined > 0, 1, 0))

# Ensure both datasets are paired (same number of observations)
if (length(Metho01_binary$pre) != length(Method02_binary$pre)) {
  stop("The data lengths for 'pre' measurements do not match!")
}

if (length(Metho01_binary$post) != length(Method02_binary$post)) {
  stop("The data lengths for 'post' measurements do not match!")
}

if (length(Metho01_binary$combined) != length(Method02_binary$combined)) {
  stop("The data lengths for 'post' measurements do not match!")
}

wilcoxon_pre <- wilcox.test(Method01_ctc$pre, Method02_ctc$pre, paired = TRUE, exact=FALSE)$p.value
wilcoxon_post <- wilcox.test(Method01_ctc$post, Method02_ctc$post, paired = TRUE, exact=FALSE)$p.value
wilcoxon_combined <- wilcox.test(Method01_ctc$combined, Method02_ctc$combined, paired = TRUE, exact=FALSE)$p.value

# McNemar Test
# prepare tables for McNemar's test
table_pre <- table(Metho01_binary$pre, Method02_binary$pre)
table_post <- table(Metho01_binary$post, Method02_binary$post)
table_combined <- table(Metho01_binary$combined, Method02_binary$combined)

# McNemar p-values
McNemar_pre <- mcnemar.test(table_pre)$p.value
McNemar_post <- mcnemar.test(table_post)$p.value
McNemar_combined <- mcnemar.test(table_combined)$p.value

# Kendall's Tau estimates: Correlation between CTC numbers
tau_pre <- cor.test(Method01_ctc$pre, Method02_ctc$pre, method="kendall")
tau_post <- cor.test(Method01_ctc$post, Method02_ctc$post, method="kendall")
tau_combined <- cor.test(Method01_ctc$combined, Method02_ctc$combined, method="kendall")

# Cohen's kappa for Pre- and Post-biopsy
kappa_pre <- kappa2(cbind(Metho01_binary$pre, Method02_binary$pre))
kappa_post <- kappa2(cbind(Metho01_binary$post, Method02_binary$post))
kappa_combined <- kappa2(cbind(Metho01_binary$combined, Method02_binary$combined))

# print results
data.frame(
  Statistic = c("Wilcoxon", "McNemar", "Kendall's Tau", "Cohen's Kappa"),
  Pre = c(
    round(wilcoxon_pre, 4),
    round(McNemar_pre, 4),
    paste0(round(tau_pre$estimate, 4), " (p=", round(tau_pre$p.value, 4), ")"),
    paste0(round(kappa_pre$value, 4), " (p=", round(kappa_pre$p.value, 4), ")")),
  Post = c(
    round(wilcoxon_post, 4),
    round(McNemar_post, 4),
    paste0(round(tau_post$estimate, 4), " (p=", round(tau_post$p.value, 4), ")"),
    paste0(round(kappa_post$value, 4), " (p=", round(kappa_post$p.value, 4), ")")),
  Combined = c(
    round(wilcoxon_combined, 4),
    round(McNemar_combined, 4),
    paste0(round(tau_combined$estimate, 4), " (p=", round(tau_combined$p.value, 4), ")"),
    paste0(round(kappa_combined$value, 4), " (p=", round(kappa_combined$p.value, 4), ")"))) |>
  flextable() |>
    set_caption(caption = "Malignant cases: Pre-, Post- and Combined Analysis") |>
    autofit()

```

# Data preparation for CTC outcomes

```{r}
# Data preparation
data <- rawdata |> 
  # select relevant columns
  filter(complete == "yes") |>
  select(Patient_ID, Cancer, contains("Method"), -Method01_preII, Stanze_type,
    contains(c("patho_", "_stage"))) |> 
  
  # Reshape data from wide to long format
  pivot_longer(
    cols = starts_with("Method"),
    names_to = c("Method", "Timepoint"),
    names_sep = "_",
    values_to = "CTC_Count") |>
  # rename Timepoints
  mutate(Timepoint = recode(Timepoint,
                            "pre" = "CTC_pre_biopsy",
                            "post" = "CTC_post_biopsy")) |>
  pivot_wider(names_from = Timepoint,    # Reshape data back to wide format
              values_from = CTC_Count) |>
  # Compute additional columns
  mutate(CTC_total = CTC_post_biopsy + CTC_pre_biopsy,
         CTC_delta = CTC_post_biopsy - CTC_pre_biopsy,
         CTCchange = factor(case_when(
           CTC_delta > 0 ~ "CTC_inc",
           CTC_delta < 0 ~ "CTC_dec",
           CTC_delta == 0 & CTC_total != 0 ~ "stable_pos",
           TRUE ~ "stable_neg"),
           levels = c("CTC_dec", "CTC_inc", "stable_pos", "stable_neg")),
         CTCoutcome = factor(case_when(
           CTCchange %in% c("CTC_dec", "stable_neg") ~ "fav",
           CTCchange %in% c("CTC_inc", "stable_pos") ~ "unfav"),
           levels = c("fav", "unfav")),
         ER_status = factor(patho_ER, levels = c(0:12)) |>
           fct_collapse("0" = "0", other_level = ">0"),
         PR_status = factor(patho_PR, levels = c(0:12)) |>
           fct_collapse("0" = "0", other_level = ">0"),
         Ki67_status = factor(case_when(
           patho_Ki67 <= 15 ~ "low (<=15%)",
           patho_Ki67 > 15 ~ "high (>15%)"),
           levels = c("low (<=15%)", "high (>15%)")),
         'T-stage' = factor(case_when(
           T_stage <= 2 ~ "T1+T2",
           T_stage > 2 ~ "T3"),
           levels = c("T1+T2", "T3")),
         'G-stage' = factor(case_when(
           G_stage <= 2 ~ "G1+G2",
           G_stage > 2 ~ "G3"),
           levels = c("G1+G2", "G3")))
  
# data structure
# flextable(tibble(Structure_data = capture.output(str(data)))) |> autofit()
# head(data, n=10) |> flextable()

```

# Table 4 and 5: Univariable analysis on fav- & unfavorable CTC outcomes

```{r}
#| eval: false
variables <- c("Stanze_type","ER_status","PR_status","patho_HER2",
               "Ki67_status", "T-stage","N_stage","M_stage","G-stage",
               "L_stage","V_stage","n_stage","R_stage")

# Overall cases
data |>
  # Select "Method01" or "Method02"
  filter(Method == "Method01") |>
  # Select "overall" or "malignant" cases
  filter(Cancer %in% c("positive", "negative")) |> 
  ## Loop through each variable and generate the result
  compare_n_qualvars(dep_vars = variables,
                   indep_var = "CTCoutcome") |> 
  rename(favorable = descfav, unfavorable = descunfav) |> 
  flextable()|> autofit() |> 
  bg(~p!=" ",1:5,bg = 'lightgrey') |> 
  align(~p==" ",1, align = "center")|> 
  # Add a main heading across all columns
  add_header_row(
    values = "Univariable analysis on fav- & unfavorable CTC outcomes
    (overall cases, n=149)",
                 colwidths = 5) |> 
  bold(part = "header")


# Malignant cases
data |> 
  # Select "Method01" or "Method02"
  filter(Method == "Method01") |>    
  # Select "overall" or "malignant" cases
  filter(Cancer %in% c("positive")) |>
  ## Loop through each variable and generate the result
  compare_n_qualvars(dep_vars = variables,
                   indep_var = "CTCoutcome") |> 
  rename(favorable = descfav, unfavorable = descunfav) |> 
  flextable()|> autofit() |> 
  bg(~p!=" ",1:5,bg = 'lightgrey') |> 
  align(~p==" ",1, align = "center")|> 
  # Add a main heading across all columns
  add_header_row(
    values = "Univariable analysis on fav- & unfavorable CTC outcomes
    (malignant cases, n=94)",
                 colwidths = 5) |> 
  bold(part = "header")

```

# Table 6 and 7: Univariable analysis on cases identified with CTCs

```{r}
#| eval: false
# Malignant cases with 0 or >0 CTCs
data |>
  filter(Method == "Method01") |>
  filter(Cancer=="positive") |>
  mutate(
    CTCoutcome = factor(case_when(
      CTCchange %in% c("stable_neg") ~ "0",
      CTCchange %in% c("CTC_inc", "stable_pos", "CTC_dec") ~ ">0"),
      levels = c("0", ">0"))) |> 
  compare_n_qualvars(dep_vars = variables,
                   indep_var = "CTCoutcome") |> 
  rename("0" = "desc0", ">0" = "desc>0") |> 
  flextable()|> autofit() |> 
  bg(~p!=" ",1:5,bg = 'lightgrey') |> 
  align(~p==" ",1, align = "center") |> 
  add_header_row(
    values = "Univariable analysis on cases identified with 0 or >0 CTCs
    (Malignant cases, n=94)",
                 colwidths = 5) |> 
  bold(part = "header")

# Overall cases with 0:1 or >1 CTC
data |>
  filter(Method == "Method01") |>
  filter(Cancer == "positive") |>
  mutate(CTCchange = factor(case_when(
            CTC_delta > 1 ~ "CTC_inc",
            CTC_delta < -1 ~ "CTC_dec",
            TRUE ~ "baseline"),
            levels = c("CTC_inc", "CTC_dec", "baseline")),
          CTCoutcome = factor(case_when(
             CTCchange %in% c("CTC_dec", "CTC_inc") ~ "unfav",
             CTCchange %in% c("baseline") ~ "fav"),
             levels = c("fav", "unfav"))) |> 
  compare_n_qualvars(dep_vars = variables,
                   indep_var = "CTCoutcome") |> 
  rename("0:1" = descfav, ">1" = descunfav) |> 
  flextable()|> autofit() |> 
  bg(~p!=" ",1:5,bg = 'lightgrey') |> 
  align(~p==" ",1, align = "center")|> 
  # Add a main heading across all columns
  add_header_row(
    values = "Univariable analysis on cases identified with 0:1 or >1 CTCs
    (Malignant cases, n=94)",
                 colwidths = 5) |> 
  bold(part = "header")

```

# Plot showing the recruitment of subjects over the study period

```{r}
#| eval: false
# cases by clinic
rawdata |> filter(complete=="yes") |> group_by(Clinic) |> summarise(n())
# plot
rawdata |>
  select(Date_Acrual, complete, CApositive)  |> 
  drop_na(Date_Acrual) |>
  #filter(complete.cases(Date_Acrual)) |>
  filter(complete == "yes") |>
  mutate(Individuals = seq(1:length(Date_Acrual))) |>
  mutate(Date_Acrual = as.Date(Date_Acrual)) |>
  ggplot(aes(x = sort(Date_Acrual), y = Individuals,
             color=CApositive)) + 
  geom_point(size = 2, shape = 2, alpha = 0.75) +
  # to include the smooth curve:
  # geom_smooth(method = 'lm', formula = y ~ poly(x, 2), color = 'red', se = FALSE) +
  scale_x_date(labels = date_format("%m/%Y"), date_breaks = "5 month") +
  scale_y_continuous(breaks = seq(0, 150, 20)) +
  labs(title = "Study recruitment from 05/2020 to 10/2023",
       x = "Timeline (month/Year)",
       y = "Recruited subjects",
      color = "Cancer positive") +
  theme_bw() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),  # Center, bold
    axis.title.x = element_text(size = 12, face = "bold", margin = margin(t = 10)),
    axis.title.y = element_text(size = 12, face = "bold"),
    # text = element_text(size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.ticks.x = element_line(size = 0.5)) +
  facet_grid(rows=vars(CApositive))

```

# Waterfall plot for CellSeach and Parsortix

```{r}
#| eval: false
# Define labeller
count_labeller <- as_labeller(function(value) {
  counts <- data %>%
    filter(Method %in% c("Method01", "Method02")) %>%
    distinct(Patient_ID, Cancer) %>%
    group_by(Cancer) %>%
    summarize(count = n(), .groups = "drop") %>%
    mutate(label = case_when(
      Cancer == "positive" ~ paste0("Cancer positive (n=", count, ")"),
      Cancer == "negative" ~ paste0("Cancer negative (n=", count, ")")
    ))
  label_map <- setNames(counts$label, counts$Cancer)
  ifelse(value %in% names(label_map), label_map[value], paste0(value, " (n=0)"))
})

# Prepare data with ordered CTCdelta
plot_data <- data %>%
  filter(Method %in% c("Method01", "Method02")) %>%
  mutate(CTCdelta = CTC_post_biopsy - CTC_pre_biopsy,
         CTCdelta = case_when(
           CTCdelta == 0 & CTC_total != 0 ~ 1,
           CTC_total == 0 ~ 0.05,
           TRUE ~ CTCdelta
         ),
         Cancer = factor(Cancer, levels = c("positive", "negative"))) %>%
  arrange(Cancer, Method, CTCdelta) %>%  # Order by CTCdelta within groups
  group_by(Cancer, Method) %>%
  mutate(women = row_number()) %>%  # Reassign women as rank of CTCdelta
  ungroup()

# Function to create plots
create_cancer_plot <- function(method, cancer_type, data) {
  data_subset <- filter(data, Method == method, Cancer == cancer_type)
  if (nrow(data_subset) == 0) return(ggplot() + theme_void() + ggtitle(paste("No data for", method, "-", cancer_type)))
  ggplot(data_subset, aes(x = women, y = CTCdelta, fill = Cancer)) +
    geom_bar(stat = "identity", width = 0.8) +
    labs(y = if (cancer_type == "positive") "CTC change from baseline" else NULL, x = "Recruited women") +
    scale_x_continuous(breaks = seq(0, max(data_subset$women, na.rm = TRUE), by = 10)) +
    scale_y_continuous(limits = c(-3, 6)) +
    scale_fill_manual(values = c("positive" = "#0072B2", "negative" = "#D55E00")) +
    theme_bw() +
    theme(panel.grid.major.y = element_blank(), text = element_text(size = 14), legend.position = "none") +
    facet_grid(cols = vars(Cancer), labeller = count_labeller)
}

# Combine plots with titles
combined_plot <- (
  wrap_elements(
    create_cancer_plot("Method01", "positive", plot_data) + 
    create_cancer_plot("Method01", "negative", plot_data) + 
    plot_layout(widths = c(3.3, 1.7)) + 
    plot_annotation(
      title = "Waterfall plot for Method01 - CellSearch detected CTCs",
      theme = theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold", margin = margin(t = 0, b = 1)))
    )
  ) /
  wrap_elements(
    create_cancer_plot("Method02", "positive", plot_data) + 
    create_cancer_plot("Method02", "negative", plot_data) + 
    plot_layout(widths = c(3.3, 1.7)) + 
    plot_annotation(
      title = "Waterfall plot for Method02 - Parsortix detected CTCs",
      theme = theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold", margin = margin(t = 0, b = 1)))
    )
  )
)

# Display final combined plot
combined_plot

```

# Plotting CTC distribution

```{r}
#| eval: false
# Relabel Time as pre-biopsy and post-biopsy
# modeldata$all_groups <- modeldata$all_groups %>%
#   mutate(Time = factor(Time,
#                        levels = c("pre", "post"),
#                        labels = c("pre-biopsy", "post-biopsy")))

ggplot(modeldata$all_groups, aes(x = Time, y = Count)) + 
  # Violin plot for distribution
  geom_violin(trim = FALSE, alpha = 0.3) +

  # Median + IQR (Interquartile Range) error bars
  # stat_summary(
  #   fun.data = function(y) {
  #     q <- quantile(y, probs = c(0.25, 0.5, 0.75))
  #     data.frame(y = q[2], ymin = q[1], ymax = q[3])
  #   },
  #   geom = "errorbar", width = 0.2, color = "black"
  # ) +
  # stat_summary(
  #   fun = median, geom = "point", shape = 95, size = 6, color = "black"
  # ) +

  # Jittered points for Count == 0 (wider spread)
  geom_jitter(data = subset(modeldata$all_groups, Count == 0),
              aes(color = Cancer),
              position = position_jitter(width = 0.3, height = 0.1),
              alpha = 1, size = 1.5, shape = 16) +

  # Jittered points for Count > 0 (narrow spread)
  geom_jitter(data = subset(modeldata$all_groups, Count > 0),
              aes(color = Cancer),
              position = position_jitter(width = 0.1, height = 0.1),
              alpha = 1, size = 1.5, shape = 16) +

  facet_grid(rows = vars(Method), cols = vars(Cancer)) +
  scale_color_manual(values = c("#F8766D", "#619CFF")) +
  theme(
    strip.text.x = element_blank(),
    strip.text.y = element_text(face = "bold"),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 12)
  ) +
  labs(
    x = "Time-point",
    y = "CTC count",
    title = "CTC count distribution by Methods and Time-point across all subjects"
  )

```

# Plotting CTC dynamics

```{r}
#| eval: false
# Create the plot dataset
plot_data <- data |>
  filter(Method == "Method02") |>
  filter(Cancer=="positive") |> 
  select(Patient_ID, Cancer, Method, CTCchange, CTC_pre_biopsy, CTC_post_biopsy) |> 
  pivot_longer(cols = contains("CTC_"),
              names_to = "Timepoint",
              values_to = "CTC_count") |> 
  group_by(Patient_ID) |>
  filter(any(CTC_count != 0)) |>
  ungroup() |>
  mutate(Timepoint = factor(Timepoint, levels = c("CTC_pre_biopsy", "CTC_post_biopsy")))

# Process data and include dummy panels dynamically
panels_per_row <- 6

# Add dummy Patient_IDs if needed to balance panels
patient_ids <- unique(plot_data$Patient_ID)
num_dummies <- ceiling(length(patient_ids) / panels_per_row) * panels_per_row - length(patient_ids)

if (num_dummies > 0) {
  dummy_ids <- paste0("Dummy_", seq_len(num_dummies))
  dummy_data <- tibble(
    Patient_ID = dummy_ids,
    Cancer = NA,
    Method = "Method02",
    Timepoint = factor(c("CTC_pre_biopsy", "CTC_post_biopsy"), 
                       levels = c("CTC_pre_biopsy", "CTC_post_biopsy")),
    CTC_count = 0,
    CTCchange = NA)
  plot_data <- bind_rows(plot_data, dummy_data)
  }

# Ensure Patient_ID ordering includes dummy IDs and/or reverse row order
rows <- split(patient_ids, ceiling(seq_along(patient_ids) / panels_per_row))  # Split into rows
# ordered_ids <- unlist(rev(rows))  # Reverse rows and flatten into a single vector

plot_data <- plot_data |>
  mutate(Patient_ID = factor(Patient_ID, levels = c(patient_ids, dummy_ids)))
  # mutate(Patient_ID = factor(Patient_ID, levels = ordered_ids))

# Create the plot
ggplot(plot_data, aes(x = Timepoint, y = CTC_count, group = Patient_ID)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 0.5) + # Baseline at y = 0
  geom_line(data = plot_data |> filter(!grepl("Dummy_", Patient_ID)), alpha = 0.5, linewidth = 0.8) + # Exclude dummy panels
  
  # Pre-Biopsy Timepoint - Circles
  geom_point(
    data = plot_data |> 
      filter(Timepoint == "CTC_pre_biopsy" & !grepl("Dummy_", Patient_ID)),
    aes(x = Timepoint, y = CTC_count),
    shape = 21, size = 3, fill = "white", color = "black"
  ) +
  
  # Post-Biopsy Timepoint - Based on CTC Change
  geom_point(
    data = plot_data |> 
      filter(Timepoint == "CTC_post_biopsy" & !grepl("Dummy_", Patient_ID)),
    aes(shape = CTCchange, x = Timepoint, y = CTC_count, fill = CTCchange),
    size = 3, color = "black"
  ) +
  
  scale_shape_manual(values = c(
    "CTC_inc" = 24,   # Upward triangle
    "CTC_dec" = 25,   # Downward triangle
    "stable_pos" = 21   # Circle
  )) +
  
  scale_fill_manual(values = c(
    "CTC_inc" = "black",
    "CTC_dec" = "black",
    "stable_pos" = "white"  # Circle stays white for "no_change"
  )) +
  
  scale_x_discrete(labels = c("CTC_pre_biopsy" = "pre-biopsy", 
                              "CTC_post_biopsy" = "post-biopsy")) +
  scale_y_continuous(breaks = seq(0, 8, by = 2), limits = c(-1, 7.5)) +
  labs(
    title = "Malignant cases: Parsortix CTC dynamics compared to baseline",
    x = "Timepoint",  # Add X-axis title
    y = "CTC count"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),  # Center, bold
    # X-axis title
    axis.title.x = element_text(size = 12, face = "bold", margin = margin(t = 10)),
    axis.title.y = element_text(size = 12, face = "bold"), # Y-axis title
    axis.text.x = element_text(size = 9, face = "bold", angle = 90, hjust = 1, vjust = 0.5),     # Smaller rotated X-axis labels
    axis.text.y = element_text(size = 8),   # Smaller Y-axis text
    panel.grid = element_blank(),           # Remove grid lines
    strip.text.x = element_blank(),         # Remove panel titles
    # strip.text.x = element_text(size = 10, face = "bold"),
    panel.spacing.x = unit(0.01, "lines"),   # Reduce horizontal space
    panel.spacing.y = unit(0.2, "lines"),   # Reduce vertical space
    axis.line = element_line(linewidth = 0.25),   # Add axis lines
    axis.line.x = element_blank(),          # Remove X-axis line
    axis.line.y = element_line(linewidth = 0.5),   # Retain Y-axis line
    axis.ticks.x = element_line(linewidth = 0.5), # Retain X-axis ticks
    axis.ticks = element_line(linewidth = 0.5)   # Add axis ticks
  ) +
  facet_wrap(~ Patient_ID, ncol = panels_per_row)

```

# Prepare modeling data for CTC counts

```{r}
modeldata <- data %>%
  select(Patient_ID, Cancer, Method, matches("biopsy|patho_|_stage")) %>%
  pivot_longer(cols = matches("biopsy"), 
               names_to = "Time", 
               values_to = "Count") %>%
  mutate(
    Time = factor(Time, 
                  levels = c("CTC_pre_biopsy", "CTC_post_biopsy"), 
                  labels = c("pre-biopsy", "post-biopsy")),
    Method = factor(Method, 
                    levels = c("Method01", "Method02")),
    Count = as.integer(replace_na(Count, 0))  # Ensure Count is not NULL
  ) %>%
  { 
    # Split data into Positive and Negative groups based on Cancer
      split_data <- split(., .$Cancer)
      # split_data <- split(., .$Method)

    split_data$all_subjects <- bind_rows(split_data)  
    split_data  
  } 

# Testing distribution
ctc_cap <- modeldata$positive$Count
# https://drizopoulos.github.io/GLMMadaptive/reference/extra_fams.html
# https://cran.r-project.org/web/packages/fitdistrplus/vignettes/fitdistrplus_vignette.html
plotdist(ctc_cap, discrete = TRUE, histo = TRUE)
# For improved visualization
# ggplot(data.frame(Count = ctc_cap), aes(x = Count)) +
#   geom_bar(fill = "steelblue", color = "black", alpha = 0.7) +
#   labs(title = "Empirical Distribution of CTC Counts",
#        x = "CTC Count",
#        y = "Frequency") +
#   theme_minimal(base_size = 14)

# Interpretation of the Plots
# Empirical Distribution Plot (Left Panel)
    # The vertical bars at 0, 1, 2, 3, etc. indicate discrete count values.
    # Most of the counts are close to zero, with very few observations at higher values.
    # The bar at 0 is the tallest, meaning many samples have zero CTC counts (suggesting a zero-inflated distribution).
# Empirical CDF Plot (Right Panel)
    # The CDF shows a sharp jump at 0, meaning a large portion of observations are zero.
    # Beyond zero, the distribution slowly rises, indicating fewer higher counts.
# What This Means for Distribution Fitting
# Since the data has many zeros and a small number of higher counts, a simple Poisson or Negative Binomial model might not fit well. Instead, you should consider: 
# ✅ Zero-Inflated Poisson (ZIP) – If some zeros come from an extra process (e.g., detection failure).
# ✅ Zero-Inflated Negative Binomial (ZINB) – If the data is overdispersed (variance much greater than the mean).

# Poisson is often the first choice for modeling count data
fit_pois <- fitdist(ctc_cap, "pois", discrete = TRUE)
summary(fit_pois)
plot(fit_pois)
# It uses Maximum Likelihood Estimation (MLE) to estimate the λ (lambda) parameter of the Poisson distribution
# Poisson assumes equal mean and variance. 
# If your data shows overdispersion (variance > mean), Negative Binomial is a better choice

# 1. Check Overdispersion
# Method 1: Compare Variance and Mean
cat("Mean:", mean(ctc_cap), "\nVariance:", var(ctc_cap))

#  If variance is much greater than the mean (variance ≫ mean) → Overdispersion exists, so Negative Binomial regression is better.

# Method 2: Overdispersion Test using the dispersion ratio:
cat("Dispersion Ratio:", var(ctc_cap) / mean(ctc_cap))

#  If ratio ≈ 1, Poisson is fine.
#  If ratio > 1.5, there is overdispersion → Use Negative Binomial (NB) instead.

# Method 3: Perform a Formal Overdispersion Test by running a quasi-Poisson model:
summary(glm(Count ~ Time * Method, family = quasipoisson, data = modeldata$positive))

#  If dispersion parameter > 1.5, your data is overdispersed → Use NB instead of Poisson.

# 2. Check the proportion of zeros ### Should You Use Zero-Inflated model (ZIP/ZINB)?
# ZIP models are useful when there are two types of zeros
# True zeros (natural occurrences in the data).
# Inflated zeros (extra zeros from another process, like missing data, incorrect measurements, etc.).
# If there are >80% of zeros, consider using Zero Inflated Model (ZIP/ZINB)

# sapply() applies a function to multiple elements and returns a simple matrix
sapply(list(
  positive = modeldata$positive$Count, 
  negative = modeldata$negative$Count, 
  all_groups = modeldata$all_subjects$Count), function(x) table(x == 0)) |> 
  {\(tbl) rbind(tbl, Percent_TRUE = round(tbl["TRUE", ] / colSums(tbl) * 100, 2))}()

## Conclusion ##
# Data is Over-dispersed and zero-inflated

```

# Fitting ZIP model

# Understanding ZIP Parameters

# lambda (λ): The Poisson rate parameter for the count part (including some zeros) or

# The average count in the Poisson part (for non-inflated counts).

# pi (π): The probability of being in the "zero-inflated" state (extra zeros).

```{r}
# Define the Zero-Inflated Poisson (ZIP) functions

# Density function - fixed to handle non-integer x
dzip <- function(x, lambda, pi) {
  x <- floor(x)
  ifelse(x < 0, 0, 
         ifelse(x == 0, pi + (1 - pi) * dpois(0, lambda), 
                (1 - pi) * dpois(x, lambda)))
}

# Cumulative distribution function
pzip <- function(q, lambda, pi) {
  q <- floor(q)
  ifelse(q < 0, 0, 
         pi + (1 - pi) * ppois(q, lambda))
}

# Quantile function
qzip <- function(p, lambda, pi) {
  result <- numeric(length(p))
  p0 <- pi + (1 - pi) * dpois(0, lambda)
  p_adj <- pmax(pmin((p - pi) / (1 - pi), 1), 0)
  result <- ifelse(p <= 0, 0, 
                   ifelse(p >= 1, Inf, 
                          ifelse(p <= p0, 0, 
                                 qpois(p_adj, lambda))))
  return(result)
}

# Verify summary stats
cat("Mean:", mean(ctc_cap), "\n")                                      # mu or μ
cat("Variance:", var(ctc_cap), "\n")
cat("Proportion of zeros:", sum(ctc_cap == 0) / length(ctc_cap), "\n")
cat("Mean of non-zeros:", mean(ctc_cap[ctc_cap > 0]), "\n")            # lambda

# Fit the ZIP model
fit_zip <- fitdist(ctc_cap, distr = dzip, 
                   start = list(lambda = 1.76, pi = 0.7), 
                   lower = c(0, 0), upper = c(Inf, 1))

# Display the estimated parameters
cat("\nEstimated ZIP parameters:\n")
print(fit_zip$estimate)

# Plot the fit
plot(fit_zip)

# Diagnostics
cat("\nAIC:", fit_zip$aic, "\n")
cat("Log-likelihood:", fit_zip$loglik, "\n")

```

# Fitting ZINB model

# ZINB Parameters

# mu (μ): The average count in the Negative Binomial part.

# size (θ): The dispersion parameter (smaller size = more spread).

# pi (π): The probability of extra zeros.

# Variance: How much the counts vary around the mean (var = μ + μ² / θ)

```{r}
library(fitdistrplus)

# ZINB functions
dzinb <- function(x, mu, size, pi) {
  if (mu <= 0 || size <= 0 || pi < 0 || pi > 1) return(Inf)
  x <- floor(x)
  ifelse(x < 0, 0, 
         ifelse(x == 0, pi + (1 - pi) * dnbinom(0, size = size, mu = mu), 
                (1 - pi) * dnbinom(x, size = size, mu = mu)))
}

pzinb <- function(q, mu, size, pi) {
  q <- floor(q)
  ifelse(q < 0, 0, 
         pi + (1 - pi) * pnbinom(q, size = size, mu = mu))
}

qzinb <- function(p, mu, size, pi) {
  result <- numeric(length(p))
  p0 <- pi + (1 - pi) * dnbinom(0, size = size, mu = mu)
  p_adj <- pmax(pmin((p - pi) / (1 - pi), 1), 0)
  result <- ifelse(p <= 0, 0, 
                   ifelse(p >= 1, Inf, 
                          ifelse(p <= p0, 0, 
                                 qnbinom(p_adj, size = size, mu = mu))))
  return(result)
}

# Fit ZINB with adjusted starting values
fit_zinb <- fitdist(ctc_cap, distr = dzinb, 
                    start = list(mu = 1.5, size = 0.2, pi = 0.78),  # Encourage higher pi
                    lower = c(0, 0, 0), upper = c(Inf, Inf, 1),
                    method = "mle",
                    optim.method = "Nelder-Mead",
                    control = list(maxit = 5000, reltol = 1e-10))

# Results
cat("\nEstimated ZINB parameters:\n")
print(fit_zinb$estimate)
plot(fit_zinb)
cat("\nAIC:", fit_zinb$aic, "\n")
cat("Log-likelihood:", fit_zinb$loglik, "\n")

```

```{r}

```

# Fit Poisson Mixed-Effects Model & Zero-Inflated Poisson Model

```{r}
#| eval: false
# https://drizopoulos.github.io/GLMMadaptive/reference/extra_fams.html
# Prepare data
modeldata_m01_prepost <- data |> 
  select(Patient_ID,Cancer,Method, contains("biopsy")) |> 
  pivot_longer(cols = contains("biopsy"), names_to = "Time", values_to = "Count") |> 
  mutate(
    Time = factor(Time, levels= c("CTC_pre_biopsy", "CTC_post_biopsy"),
                  labels = c("pre", "post")),
    Method = factor(Method, levels = c("Method01", "Method02"))) |> 
  filter(Method == "Method01") # try to create a loop by filtering over methods

modeldata_m02_prepost <- data |> 
  select(Patient_ID,Cancer,Method, contains("biopsy")) |> 
  pivot_longer(cols = contains("biopsy"), names_to = "Time", values_to = "Count") |> 
  mutate(
    Time = factor(Time, levels= c("CTC_pre_biopsy", "CTC_post_biopsy"),
                  labels = c("pre", "post")),
    Method = factor(Method, levels = c("Method01", "Method02"))) |> 
  filter(Method == "Method02")

modeldata_prepost <- data |> 
  select(Patient_ID,Cancer,Method, contains("biopsy")) |> 
  pivot_longer(cols = contains("biopsy"), names_to = "Time", values_to = "Count") |> 
  mutate(
    Time = as.factor(recode(Time, "CTC_pre_biopsy" = "pre", "CTC_post_biopsy" = "post")),
    Method = factor(Method, levels = c("Method01", "Method02")))

# Visualize data
modeldata_m01_prepost |> 
  ggplot(aes(Count, fill = Time)) +
  geom_histogram(position="dodge") +
  facet_grid(rows = vars(Cancer))

modeldata_m02_prepost |> 
  ggplot(aes(Count, fill = Time)) +
  geom_histogram(position="dodge") +
  facet_grid(rows = vars(Cancer))

modeldata_prepost |> 
  ggplot(aes(Count, fill = Time)) +
  geom_histogram(position="dodge") +
  facet_grid(rows = vars(Cancer), cols= vars(Method))

# Fit poisson model
poisson_m01_model <- glmer(Count ~ Time * Cancer + (1|Patient_ID), 
                   family = poisson, 
                   data = modeldata_m01_prepost)


poisson_m02_model<- glmer(Count ~ Time * Cancer + (1|Patient_ID), 
                   family = poisson, 
                   data = modeldata_m02_prepost)

poisson_model_method <- glmer(Count ~ Time * Cancer + Method + (1|Patient_ID), 
                   family = poisson, 
                   data = modeldata_prepost)

poisson_model_method_wi <- glmer(Count ~ Time + Cancer + Method + (1|Patient_ID), 
                   family = poisson, 
                   data = modeldata_prepost)

tidy(poisson_m01_model) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Poisson Mixed-Effect Model # Method01",
                 colwidths = 7) |> 
  bold(part = "header")

tidy(poisson_m02_model) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Poisson Mixed-Effect Model # Method02",
                 colwidths = 7) |> 
  bold(part = "header")

tidy(poisson_model_method) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Poisson Mixed-Effect Model",
                 colwidths = 7) |> 
  bold(part = "header")


tidy(poisson_model_method_wi) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Poisson Mixed-Effect Model without interaction",
                 colwidths = 7) |> 
  bold(part = "header")



# Fit Zero-Inflated poisson model
# glmmTMB() allows for zero-inflation, modeling cases where extra zeros arise from a separate process (e.g., some patients inherently have no CTCs)
# ziformula = ~1 means constant probability of excess zeros

# Running using GLMadaptive package
zip_model_fixed <- mixed_model(fixed = Count ~ Time * Cancer,
                         random = ~ 1 | Patient_ID,
                         data = modeldata_m01_prepost,
                         family = zi.poisson(),
                         zi_fixed = ~ 1)
                         #zi_random = ~ 1 | Patient_ID)  # optional step?

zip_model_random <- mixed_model(fixed = Count ~ Time * Cancer,
                         random = ~ 1 | Patient_ID,
                         data = modeldata_m01_prepost,
                         family = zi.poisson(),
                         zi_fixed = ~ 1,
                         zi_random = ~ 1 | Patient_ID)  # optional step?

anova(zip_model_random, zip_model_fixed)



# Running using glmTMB package
# zip_model <- glmmTMB(Count ~ Time * Cancer + (1 | Patient_ID), 
#                       ziformula = ~1, 
#                       family = poisson, 
#                       data = modeldata_m01_prepost)
tidy(zip_model) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Zero-Inflated Poisson Model # Method01",
                 colwidths = 7) |> 
  bold(part = "header")

tidy(zip_model_fixed) |> 
  mutate(across(estimate:statistic, roundR),
         p.value = formatP(p.value, 3, mark = T)) |> 
  flextable() |> 
  add_header_row(values = "Zero-Inflated Poisson Model # Method01",
                 colwidths = 7) |> 
  bold(part = "header")

summary(poisson_model)
summary(zip_model)

anova(poisson_model, zip_model)  # doesn't work?

# Use DHARMa and performace packages for comparison
poisson_resid <- simulateResiduals(poisson_model)
plot(poisson_resid)

compare_performance(zip_model_random, zip_model_fixed)
compare_performance(poisson_model, zip_model_fixed)

# Other ways to compare
# model_summary <- summary(poisson_model)
# model_summary
# model_summary$coefficients
# 
# model_parameter <- exp(fixef(poisson_model))
# 
# model_confint <- exp(confint(poisson_model))
# 
# confint(model_out, method="profile", devtol=1e-4)
# 
# confint(model_out, method="Wald")

```

# Modeling clinical parameters (T,N,M,G,L,V,R,ER,PR,HER2,Ki67)

```{r}
#| eval: false
# Convert clinical variables to factors

clinical_vars <- ColSeeker(data,
                           namepattern = c("T_stage", "N_stage", "M_stage", "G_stage",
                                           "L_stage", "V_stage", "R_stage", "patho_ER",
                                           "patho_PR","patho_HER2", "patho_Ki67"))

# Extract names
clinvars <- clinical_vars$names 

# Prepare data
modelclinvars <- data |> 
  select(Patient_ID,Cancer,Method, contains("biopsy"), all_of(clinvars)) |> 
  pivot_longer(cols = contains("biopsy"), 
               names_to = "Time", 
               values_to = "Count") |>
  filter(Cancer== "positive") |> 
  mutate(Time = as.factor(dplyr::recode(Time, "CTC_pre_biopsy" = "pre", 
                                        "CTC_post_biopsy" = "post")),
         Method = factor(Method, levels = c("Method01", "Method02")),
         across(all_of(clinical_vars$names), ~factor(.x) |> 
             fct_drop()))

cat_desc_table(modelclinvars, desc_vars = clinical_vars$names) |> view()

#cat_desc_table(drop_na(modelclinvars), desc_vars = clinical_vars$names) |> view()

# Convert the selected columns to factors
# modelclinvars[clinvars] <- lapply(modelclinvars[clinvars], factor)


# create a loop for clinvars and run the model for each clinvar

# Fit ZIP Model with Clinical Variables
zip_model <- glmmTMB(
  Count ~ Time + T_stage + N_stage + M_stage + G_stage +
          L_stage + V_stage + patho_ER + patho_PR + patho_HER2 + patho_Ki67 +
          (1 | Patient_ID),   # Random effect for individual patients
  ziformula = ~1,   # Zero-inflation formula (constant excess zero probability)
  family = poisson, 
  data = modelclinvars |> mutate(across(all_of(clinical_vars$names),
             fct_drop)))

# Display Summary
summary(zip_model)

## Modeling
# ---------------------------
# 1. Load and Prepare Data
# ---------------------------
# Assuming `modelclinvars` is already loaded
# Ensure Count is a factor for CLMM, numeric for Poisson/ZINB
modelclinvars <- modelclinvars %>%
  mutate(
    Count = as.integer(Count),  # Numeric for Poisson/ZINB
    Count_ord = factor(case_when(Count == 0 ~ "None",
                                 Count == 1 ~ "Low",
                                 Count > 1  ~ "High"),
                       levels = c("None", "Low", "High"),
                       ordered = TRUE)  # Ordered for CLMM
  )

# Define the list of clinical variables to analyze
clinical_vars <- c("patho_ER", "patho_PR", "patho_HER2", "patho_Ki67",
                   "T_stage", "N_stage", "M_stage", "G_stage",
                   "L_stage", "V_stage", "R_stage")

# ---------------------------
# 2. Define Model Fitting Functions
# ---------------------------

# Poisson Model Function
fit_poisson <- function(data, var) {
  formula <- as.formula(paste("Count ~ Time + Method +", var))  # Removed random effect
  tryCatch({
    model <- glmmTMB(formula, family = poisson, data = data)
    if (!model$fit$convergence == 0) {
      warning(paste("Poisson model for", var, "did not converge properly"))
    }
    return(model)
  }, error = function(e) {
    warning(paste("Poisson model failed for", var, ":", e$message))
    return(NULL)
  })
}

fit_zinb <- function(data, var) {
  formula <- as.formula(paste("Count ~ Time + Method +", var))  # Removed random effect
  tryCatch({
    model <- glmmTMB(formula, ziformula = ~1, family = nbinom2, data = data)
    if (!model$fit$convergence == 0) {
      warning(paste("ZINB model for", var, "did not converge properly"))
    }
    return(model)
  }, error = function(e) {
    warning(paste("ZINB model failed for", var, ":", e$message))
    return(NULL)
  })
}

fit_clmm <- function(data, var) {
  formula <- as.formula(paste("Count_ord ~ Time + Method +", var))
  tryCatch({
    model <- clm(formula, data = data)
    return(model)
  }, error = function(e) {
    warning(paste("CLM model failed for", var, ":", e$message))
    return(NULL)
  })
}

# ---------------------------
# 3. Run Models in a Loop
# ---------------------------
results <- list()

for (var in clinical_vars) {
  cat("Fitting models for:", var, "\n")
  
  # Fit Models
  poisson_model <- fit_poisson(modelclinvars, var)
  zinb_model    <- fit_zinb(modelclinvars, var)
  clmm_model    <- fit_clmm(modelclinvars, var)
  
  # Store Models
  results[[var]] <- list(poisson = poisson_model,
                         zinb = zinb_model,
                         clmm = clmm_model)
}

# ---------------------------
# 4. Extract and Process Model Results
# ---------------------------

# Define the processing function
process_model_results <- function(results) {
  model_results <- map_dfr(names(results), function(var) {
    models <- results[[var]]
    bind_rows(
      lapply(names(models), function(model_name) {
        model <- models[[model_name]]
        if (is.null(model)) return(NULL)
        
        tryCatch({
          if (inherits(model, "glmmTMB")) {
            df <- tidy(model, effects = c("fixed", "ran_pars"), conf.int = TRUE)
          } else if (inherits(model, "clm")) {  # Changed from "clmm" to "clm"
            df <- as_tibble(coef(summary(model))) %>%
              rename(estimate = Estimate, std.error = `Std. Error`,
                     statistic = `z value`, p.value = `Pr(>|z|)`) %>%
              mutate(term = rownames(coef(summary(model))), effect = "fixed")
          } else {
            return(NULL)
          }
          
          df <- df %>%
            mutate(
              clinical_var = var,
              model = model_name,
              across(c(estimate, std.error, statistic), ~round(.x, 3)),
              p.value = formatP(p.value, 3, mark = TRUE)
            )
          
          return(df)
          
        }, error = function(e) {
          warning(paste("Error processing", model_name, "for", var, ":", e$message))
          return(NULL)
        })
      })
    )
  })
  
  return(model_results)
}


# Process the results
final_results <- process_model_results(results)
final_results <- final_results %>%
  select(
    Model = model,
    `Clinical Variable` = clinical_var,
    Term = term,
    Estimate = estimate,
    `Std. Error` = std.error,
    Statistic = statistic,
    `P-value` = p.value,
    `Conf. Low` = conf.low,
    `Conf. High` = conf.high
  )

# ---------------------------
# 5. Generate Flextable Report
# ---------------------------
make_flextable <- function(df, title) {
  if (nrow(df) == 0) return(NULL)
  
  ft <- flextable(df) %>%
    add_header_lines(values = paste0("**", title, "**")) %>%
    bold(part = "header") %>%
    set_table_properties(layout = "autofit") %>%
    fontsize(size = 9, part = "header") %>%
    fontsize(size = 9, part = "body") %>%
    padding(padding = 4) %>%
    bg(i = which(is.na(df[["Term"]])), bg = "#D3D3D3") %>%
    bold(i = which(is.na(df[["Term"]])), bold = TRUE)
  
  return(ft)
}

# Create the flextable
final_flextable <- make_flextable(final_results, "Multivariable Analysis Results (Poisson, ZINB, CLMM)")
print(final_flextable)

# Save results to a Word file
save_as_docx(final_flextable, path = "Multivariable_Analysis_Results.docx")

```

# Ordinal analysis with cumulative link mixed effect models

```{r}
#| eval: false
clmm_model <- clmm(factor(Count) ~ Time * Cancer + (1|Patient_ID), 
                   threshold = 'equidistant',
                   data = modeldata_m01_prepost)

reduced_model_i <- clmm(factor(Count) ~ Time + Cancer + (1|Patient_ID), 
                   threshold = 'equidistant',
                   data = modeldata_m01_prepost)
anova(reduced_model_i, clmm_model)


reduced_model_c <- clmm(factor(Count) ~ Time + (1|Patient_ID), 
                   threshold = 'equidistant',
                   data = modeldata_m01_prepost)
anova(reduced_model_c, reduced_model_i, clmm_model)

summary(clmm_model)
confint(clmm_model) |> exp()
tidy(clmm_model)|> 
  mutate(across(estimate:statistic, roundR),
         p.value=formatP(p.value,3,mark=T)) |> 
  flextable()

```

# Testing models : Poisson, ZIP, CLMM

```{r}
# ---------------------------
# 1. Prepare data
# ---------------------------

# Ensure all elements are data frames
modeldata <- map(modeldata, as.tibble)

# ---------------------------
# 2. Visualization step **before** fitting models
# ---------------------------
plots <- imap(modeldata, ~ ggplot(.x, aes(Count, fill = Time)) +
                geom_histogram(position = "dodge", bins = 10) +
                facet_grid(rows = vars(Cancer), cols = vars(Method)) +
                ggtitle(.y) +
                # theme_minimal() +
                scale_fill_manual(values = c("pre-biopsy" = "#1B9E77", "post-biopsy" = "#D95F02")))

# Print plots (optional)
# walk(plots, print)

# ---------------------------
# 3. Fit models
# ---------------------------
cat("Fitting models...\n")
models <- map(names(modeldata), function(name) {
  fit_models <- function(data, name) {
    data_numeric <- data %>% mutate(Count = as.integer(Count))
    data_factor  <- data %>% mutate(Count = as.ordered(Count))
    
    if (name == "all_subjects") {
      models <- list(
        poisson_reg_noi = glmer(Count ~ Time + Cancer + Method + (1 | Patient_ID),
                                        family = poisson, 
                                        data = data_numeric),
        poisson_reg_i = glmer(Count ~ Time * Cancer + Method + (1 | Patient_ID),
                                        family = poisson, 
                                        data = data_numeric),
        zip_reg_noi = tryCatch(mixed_model(fixed = Count ~ Time + Cancer + Method,
                                        random = ~ 1 | Patient_ID, 
                                        family = zi.poisson(),
                                        zi_fixed = ~ 1, 
                                        data = data_numeric), 
                                        error = function(e) NULL),
        zip_reg_i = tryCatch(mixed_model(fixed = Count ~ Time * Cancer + Method,
                                        random = ~ 1 | Patient_ID, 
                                        family = zi.poisson(),
                                        zi_fixed = ~ 1, 
                                        data = data_numeric), 
                                        error = function(e) NULL),
        clmm_reg_noi = tryCatch(clmm(Count ~ Time + Cancer + Method + (1 | Patient_ID),
                                        data = data_factor, 
                                        threshold = "equidistant"), 
                                        error = function(e) NULL),
        clmm_reg_i = tryCatch(clmm(Count ~ Time * Cancer + Method + (1 | Patient_ID),
                                        data = data_factor, 
                                        threshold = "equidistant"), 
                                        error = function(e) NULL))
    } else {
      models <- list(
        poisson_red  = tryCatch(glmer(Count ~ Time + (1 | Patient_ID),
                                          family = poisson, 
                                          data = data_numeric), 
                                          error = function(e) NULL),
        poisson_red_i = tryCatch(glmer(Count ~ Time * Cancer + (1 | Patient_ID),
                                          family = poisson, 
                                          data = data_numeric), 
                                          error = function(e) NULL),
        poisson_red_noi = tryCatch(glmer(Count ~ Time + Cancer + (1 | Patient_ID),
                                          family = poisson, 
                                          data = data_numeric), 
                                          error = function(e) NULL),
        zip_red = tryCatch(mixed_model(fixed = Count ~ Time,
                                          random = ~ 1 | Patient_ID, 
                                          family = zi.poisson(),
                                          zi_fixed = ~ 1, 
                                          data = data_numeric), 
                                          error = function(e) NULL),
        zip_red_i = tryCatch(mixed_model(fixed = Count ~ Time * Cancer,
                                          random = ~ 1 | Patient_ID, 
                                          family = zi.poisson(),
                                          zi_fixed = ~ 1, 
                                          data = data_numeric), 
                                          error = function(e) NULL),
        zip_red_noi = tryCatch(mixed_model(fixed = Count ~ Time + Cancer,
                                          random = ~ 1 | Patient_ID, 
                                          family = zi.poisson(),
                                          zi_fixed = ~ 1, 
                                          data = data_numeric), error = function(e) NULL),
        clmm_red = tryCatch(clmm(Count ~ Time + (1 | Patient_ID),
                                          data = data_factor,
                                          threshold = "equidistant"),
                                          error = function(e) NULL),
        clmm_red_i = tryCatch(clmm(Count ~ Time * Cancer + (1 | Patient_ID),
                                          data = data_factor,
                                          threshold = "equidistant"), 
                                          error = function(e) NULL),
        clmm_red_noi = tryCatch(clmm(Count ~ Time + Cancer + (1 | Patient_ID),
                                          data = data_factor,
                                          threshold = "equidistant"), 
                                          error = function(e) NULL)
      )
    }
    models
  }
  models_list <- fit_models(modeldata[[name]], name)
  setNames(models_list, tolower(paste0(names(models_list), "_", name)))
}) %>% do.call(c, .)

# ---------------------------
# 4. Process model results into tables
# ---------------------------
model_results <- imap(models, ~ {
  if (is.null(.x)) return(NULL)
  
  tryCatch({
    if (inherits(.x, "glmerMod")) {
      df <- tidy(.x, effects = c("fixed", "ran_pars"), check_conv = TRUE)
    } else if (inherits(.x, "MixMod")) {
      fixed_df <- tidy(.x, effects = "fixed", check_conv = TRUE)
      ran_list <- tryCatch(VarCorr(.x), error = function(e) NULL)
      
      ran_df <- if (!is.null(ran_list) && length(ran_list) > 0) {
        bind_rows(lapply(names(ran_list), function(grp) {
          temp <- as.data.frame(ran_list[[grp]])
          sd_value <- if ("sdcor" %in% names(temp)) temp$sdcor else if ("Std.Dev." %in% names(temp)) temp$`Std.Dev.` else if ("vcov" %in% names(temp)) sqrt(temp$vcov) else if ("Variance" %in% names(temp)) sqrt(temp$Variance) else NA
          tibble(term = paste0("sd__(Intercept):", grp), estimate = sd_value, effect = "ran_pars")
        }))
      } else {
        tibble(term = "ran_pars", estimate = NA, effect = "ran_pars")
      }
      
      df <- bind_rows(fixed_df, ran_df)
    } else if (inherits(.x, "clmm")) {
      clmm_sum <- summary(.x)
      fixed_df <- as_tibble(coef(clmm_sum)) %>%
        mutate(term = rownames(coef(clmm_sum)), effect = "fixed") %>%
        select(term, estimate = Estimate, std.error = `Std. Error`, statistic = `z value`, p.value = `Pr(>|z|)`, effect)
      
      thresh_df <- tibble(term = names(clmm_sum$alpha), estimate = as.numeric(clmm_sum$alpha), std.error = NA, statistic = NA, p.value = NA, effect = "threshold")
      
      ran_list <- VarCorr(.x)
      ran_df <- bind_rows(lapply(names(ran_list), function(grp) {
        temp <- as.data.frame(ran_list[[grp]])
        sd_value <- if ("sdcor" %in% names(temp)) temp$sdcor else if ("Std.Dev." %in% names(temp)) temp$`Std.Dev.` else if ("vcov" %in% names(temp)) sqrt(temp$vcov) else if ("Variance" %in% names(temp)) sqrt(temp$Variance) else NA
        tibble(term = paste0("sd__(Intercept):", grp), estimate = sd_value, effect = "ran_pars")
      }))
      
      df <- bind_rows(fixed_df, thresh_df, ran_df)
    } else {
      return(NULL)
    }
    
    # ---------------------------
    # Apply Formatting to Results
    # ---------------------------
    df <- df %>%
      mutate(across(estimate:statistic, roundR),
             p.value = formatP(p.value, 3, mark = TRUE))
    
    df  # Return formatted dataframe
    
  }, error = function(e) {
    message("Error in model extraction: ", e)
    NULL
  })
})


# ---------------------------
# 5. Combine models into three separate tables
# ---------------------------
poisson_models <- bind_rows(
  model_results[names(model_results) %>% keep(~ grepl("poisson", .x))], .id = "model"
)
zip_models     <- bind_rows(
  model_results[names(model_results) %>% keep(~ grepl("zip", .x))], .id = "model"
)
clmm_models    <- bind_rows(
  model_results[names(model_results) %>% keep(~ grepl("clmm", .x))], .id = "model"
)


# ---------------------------
# 6. Convert to flextables and display
# ---------------------------
make_flextable <- function(df, title) {
  if (nrow(df) == 0) return(NULL)
  
  # Create a new grouping column based on the model values.
  df <- df %>%
    mutate(group = case_when(
      grepl("method01", model) ~ "Method01_reduced_model",
      grepl("method02", model) ~ "Method02_reduced_model",
      grepl("all_methods", model) ~ "All_methods_regular_model",
      TRUE ~ "Other"
    ))
  
  # Get unique groups in order of appearance
  group_levels <- unique(df$group)
  
  # Insert header rows for each group
  new_df <- data.frame()
  for(g in group_levels) {
    header_row <- data.frame(
      model = g, 
      term = NA, 
      estimate = NA, 
      std.error = NA, 
      statistic = NA, 
      p.value = NA,
      effect = NA,
      group = NA,
      isHeader = TRUE,
      stringsAsFactors = FALSE
    )
    group_data <- df %>% filter(group == g)
    new_df <- bind_rows(new_df, header_row, group_data)
  }
  
  ft <- flextable(new_df) %>%
    add_header_lines(values = paste0("**", title, "**")) %>%  
    set_header_labels(
      term = "Term", 
      estimate = "Estimate", 
      std.error = "Std. Error", 
      statistic = "Statistic", 
      p.value = "P-value", 
      model = "Model"
    ) %>%
    bold(part = "header") %>%
    set_table_properties(layout = "autofit")
  
  ft <- ft %>% 
    compose(part = "body", j = "term", 
            value = as_paragraph(ifelse(is.na(new_df$model), new_df$term, new_df$term))) %>%
    bg(i = which(new_df$isHeader), bg = "#D3D3D3") %>%bold(i = which(new_df$isHeader), bold = TRUE)
  
  return(ft)
} 

poisson_table <- make_flextable(poisson_models, "Poisson Model Results")
zip_table     <- make_flextable(zip_models, "Zero-Inflated Poisson (ZIP) Model Results")
clmm_table    <- make_flextable(clmm_models, "Cumulative Link Mixed Model (CLMM) Results")

# Print flextables if not NULL
if (!is.null(poisson_table)) print(poisson_table)
if (!is.null(zip_table))     print(zip_table)
if (!is.null(clmm_table))    print(clmm_table)

```

# Display model comparison

```{r}
# Step: Extract Key Metrics from Each Model
model_comparison <- imap(models, ~ {
  if (is.null(.x)) return(NULL)
  tryCatch({
    model_type <- class(.x)[1]
    stats <- summary(.x)
    
    tibble(
      Model = .y,
      AIC = switch(model_type,
                   "glmerMod" = AIC(.x),
                   "MixMod" = stats$AIC,
                   "clmm" = tryCatch(AIC(.x), error = function(e) NA_real_),
                   NA_real_),
      BIC = switch(model_type,
                   "glmerMod" = BIC(.x),
                   "MixMod" = stats$BIC,
                   "clmm" = tryCatch(BIC(.x), error = function(e) NA_real_),
                   NA_real_),
      LogLik = switch(model_type,
                      "glmerMod" = as.numeric(logLik(.x)),
                      "MixMod" = as.numeric(stats$logLik),
                      "clmm" = as.numeric(logLik(.x)),
                      NA_real_),
      Fixed_Effects = paste(
        switch(model_type,
               "glmerMod" = names(fixef(.x)),
               "MixMod" = rownames(stats$coef_table),
               "clmm" = names(coef(.x)),
               ""),
        collapse = ", "
      )
    )
  }, error = function(e) NULL)
}) |> bind_rows() |> arrange(AIC) |> print()

# Plot Model Comparison
ggplot(model_comparison, aes(x = reorder(Model, AIC), y = AIC, fill = Model)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Model Comparison (AIC)", x = "Model", y = "AIC") +
  theme_minimal() +
  theme(legend.position = "none")

# Define grouping patterns
group_patterns <- list(
  "Method" = c("Method01" = "method01", "Method02" = "method02", "All Methods" = "all_methods"),
  "Model" = c("Poisson" = "poisson", "CLMM" = "clmm", "ZIP" = "zip")
)

# Function to assign group based on pattern
assign_group <- function(model_name, patterns) {
  matched_group <- names(patterns)[sapply(patterns, function(pattern) str_detect(model_name, pattern))]
  if (length(matched_group) > 0) matched_group[1] else "Other"
}

# Function to process models based on a given grouping pattern
process_models <- function(patterns) {
  df <- bind_rows(
    imap(models, ~ {
      if (!is.null(.x)) {
        tidy_result <- tidy(.x, effects = "fixed") %>%
          mutate(Model = .y, Group = assign_group(.y, patterns),
                 p.value = format.pval(p.value, digits = 3, eps = 0.001))
        if (!"effect" %in% names(tidy_result)) tidy_result <- mutate(tidy_result, effect = "fixed")
        tidy_result
      }
    })
  ) %>%
    arrange(factor(Group, levels = names(patterns)))

  # Retain only common columns
  common_columns <- names(df)[colSums(!is.na(df)) == nrow(df)]
  if("p.value" %in% common_columns) {
    common_columns <- setdiff(common_columns, "p.value") |> append("p.value")
  }
  df <- select(df, all_of(common_columns))

  # Insert headers before each group
  grouped_df <- bind_rows(map(unique(df$Group), function(g) {
    bind_rows(
      tibble(Model = g, effect = NA_character_, term = NA_character_,
             estimate = NA_real_, std.error = NA_real_, statistic = NA_real_,
             p.value = NA_character_),
      filter(df, Group == g)
    )
  })) %>%
    select(-Group)

  return(grouped_df)
}

# Generate flextables with proper formatting
tables <- imap(group_patterns, ~ {
  flextable(process_models(.x)) %>%
    bold(i = which(is.na(process_models(.x)$effect)), part = "body") %>%  # Bold group headers
    bold(part = "header") %>%  # Bold variable names (default size)
    theme_vanilla() %>%
    add_header_lines(paste("Model Comparison Grouped by", .y)) %>%
    bold(part = "header") %>%
    fontsize(i = 1, part = "header", size = 14)  # Set title to size 14 and bold
})

# Display both flextables
tables$Method  # Flextable for Method-based grouping
tables$Model   # Flextable for Model Type-based grouping

```

# Final plots after modeling

```{r}
modeldata$all_groups |> 
  ggplot(aes(Method, Count,  color= Time)) +
  # geom_beeswarm(dodge.width = 0.75, cex = 0.5)
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))

modeldata$all_groups |> 
  ggplot(aes(Time, Count,  color= Method)) +
  # geom_beeswarm(dodge.width = 0.75, cex = 0.5)
  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))

```

```{r}
# Define the Zero-Inflated Poisson (ZIP) functions

# Density function
dzip <- function(x, lambda, pi) {
  x <- floor(x)
  ifelse(x < 0, 0, 
         ifelse(x == 0, pi + (1 - pi) * dpois(0, lambda), 
                (1 - pi) * dpois(x, lambda)))
}

# Cumulative distribution function
pzip <- function(q, lambda, pi) {
  q <- floor(q)
  ifelse(q < 0, 0, 
         pi + (1 - pi) * ppois(q, lambda))
}

# Quantile function
qzip <- function(p, lambda, pi) {
  result <- numeric(length(p))
  p0 <- pi + (1 - pi) * dpois(0, lambda)
  p_adj <- pmax(pmin((p - pi) / (1 - pi), 1), 0)
  result <- ifelse(p <= 0, 0, 
                   ifelse(p >= 1, Inf, 
                          ifelse(p <= p0, 0, 
                                 qpois(p_adj, lambda))))
  return(result)
}

# Define the negative log-likelihood function for ZIP
zip_nll <- function(params, data) {
  lambda <- params[1]
  pi <- params[2]
  -sum(log(dzip(data, lambda, pi)))
}

# Fit the ZIP model using optim()
fit_zip_optim <- optim(c(1, 0.5), zip_nll, 
                       data = ctc_cap, 
                       method = "L-BFGS-B", 
                       lower = c(0, 0), 
                       upper = c(Inf, 1))

# Extract the estimated parameters from optim
lambda_optim <- fit_zip_optim$par[1]
pi_optim <- fit_zip_optim$par[2]

# Print the results from optim
cat("\nZIP Model (optim):\n")
cat("Lambda (Poisson mean):", lambda_optim, "\n")
cat("Pi (Zero-inflation probability):", pi_optim, "\n")

# Fit the ZIP model using fitdist (for comparison and diagnostics)
fit_zip_fitdist <- fitdist(ctc_cap, distr = dzip, 
                           start = list(lambda = lambda_optim, pi = pi_optim), 
                           lower = c(0, 0), upper = c(Inf, 1))

# Display the estimated parameters from fitdist
cat("\nZIP Model (fitdist):\n")
print(fit_zip_fitdist$estimate)

# Plot the fit
plot(fit_zip_fitdist)

# Diagnostics
cat("AIC:", fit_zip_fitdist$aic, "\nBIC:", fit_zip_fitdist$bic, 
    "\nLog-likelihood:", fit_zip_fitdist$loglik)

# Compare optim and fitdist results
cat("\nComparison of Estimates:\n")
cat("Lambda (optim):", lambda_optim, "\n")
cat("Lambda (fitdist):", fit_zip_fitdist$estimate["lambda"], "\n")
cat("Pi (optim):", pi_optim, "\n")
cat("Pi (fitdist):", fit_zip_fitdist$estimate["pi"], "\n")

```

```{r}
# Load required packages
library(fitdistrplus)

# Define the Zero-Inflated Negative Binomial (ZINB) functions

# Density function for ZINB
dzinb <- function(x, mu, theta, pi) {
  x <- floor(x)
  ifelse(x < 0, 0, 
         ifelse(x == 0, pi + (1 - pi) * dnbinom(0, size = theta, mu = mu), 
                (1 - pi) * dnbinom(x, size = theta, mu = mu)))
}

# Cumulative distribution function for ZINB
pzinb <- function(q, mu, theta, pi) {
  q <- floor(q)
  ifelse(q < 0, 0, 
         pi + (1 - pi) * pnbinom(q, size = theta, mu = mu))
}

# Quantile function for ZINB
qzinb <- function(p, mu, theta, pi) {
  result <- numeric(length(p))
  p0 <- pi + (1 - pi) * dnbinom(0, size = theta, mu = mu)
  p_adj <- pmax(pmin((p - pi) / (1 - pi), 1), 0)
  result <- ifelse(p <= 0, 0, 
                   ifelse(p >= 1, Inf, 
                          ifelse(p <= p0, 0, 
                                 qnbinom(p_adj, size = theta, mu = mu))))
  return(result)
}

# Define the negative log-likelihood function for ZINB
zinb_nll <- function(params, data) {
  mu <- params[1]
  theta <- params[2]
  pi <- params[3]
  # Ensure parameters are within valid ranges
  if (mu <= 0 || theta <= 0 || pi < 0 || pi > 1) return(Inf)
  -sum(log(dzinb(data, mu, theta, pi)))
}

# Fit the ZINB model using optim()
fit_zinb_optim <- optim(c(1, 1, 0.5), zinb_nll, 
                        data = ctc_cap, 
                        method = "L-BFGS-B", 
                        lower = c(0, 0, 0), 
                        upper = c(Inf, Inf, 1))

# Extract the estimated parameters from optim
mu_optim <- fit_zinb_optim$par[1]
theta_optim <- fit_zinb_optim$par[2]
pi_optim <- fit_zinb_optim$par[3]

# Print the results from optim
cat("\nZINB Model (optim):\n")
cat("Mu (Negative Binomial mean):", mu_optim, "\n")
cat("Theta (Dispersion parameter):", theta_optim, "\n")
cat("Pi (Zero-inflation probability):", pi_optim, "\n")

# Fit the ZINB model using fitdist (for comparison and diagnostics)
fit_zinb_fitdist <- fitdist(ctc_cap, distr = dzinb, 
                            start = list(mu = mu_optim, theta = theta_optim, pi = pi_optim), 
                            lower = c(0, 0, 0), 
                            upper = c(Inf, Inf, 1))

# Display the estimated parameters from fitdist
cat("\nZINB Model (fitdist):\n")
print(fit_zinb_fitdist$estimate)

# Plot the fit
plot(fit_zinb_fitdist)

# Diagnostics
cat("AIC:", fit_zinb_fitdist$aic, "\nBIC:", fit_zinb_fitdist$bic, 
    "\nLog-likelihood:", fit_zinb_fitdist$loglik)

# Compare optim and fitdist results
cat("\nComparison of Estimates:\n")
cat("Mu (optim):", mu_optim, "\n")
cat("Mu (fitdist):", fit_zinb_fitdist$estimate["mu"], "\n")
cat("Theta (optim):", theta_optim, "\n")
cat("Theta (fitdist):", fit_zinb_fitdist$estimate["theta"], "\n")
cat("Pi (optim):", pi_optim, "\n")
cat("Pi (fitdist):", fit_zinb_fitdist$estimate["pi"], "\n")
```
